# Course: CS4306-01
# Student name: Jonathan Miu
# Student ID: 000456452
# Programming Assignment #3
# Due Date: November 13, 2018
# Signature: jmiu
# (The signature means that the program is your own work)
# Score: ______________


import random
import sys
import time
import os.path
import json

filename = 'export'
random.seed()

def create_matrix(size) :
	global matrix
	matrix = []
	for i in range(size) :
		templist = []
		for i in range(size) :
			templist.append(0)
		matrix.append(templist)

def randomize_matrix(max, chance) :
	global matrix
	for i in range(len(matrix)) :
		for j in range(len(matrix[i])) :
			if i != j and random.random() <= chance :
				matrix[i][j] = random.randint(1, max)
	# just trying to make sure the matrix is actually solvable (it might still not be after this, but it helps)
	for i in range(len(matrix)) :
		solvable = False
		for j in range(len(matrix[i])) :
			if matrix[i][j] > 0 :
				solvable = True
		if not solvable :
			j = i
			while j == i :
				j = random.randint(0, len(matrix[i]) - 1)
			matrix[i][j] = random.randint(1, max)

def print_matrix() :
	for i in range(len(matrix)) :
		print(matrix[i])

def is_int(s):
    try: 
        int(s)
        return True
    except ValueError:
        return False

def is_float(s):
    try: 
        float(s)
        return True
    except ValueError:
        return False

def find_shortest(start) :
	global matrix
	failures = []
	path = []
	current = start
	# just give up after this many failures (there seems to be a bug causing it to occasionally run forever that I just *can't* find)
	maxfailures = 10000 #len(matrix) * len(matrix[current])

	while len(path) < len(matrix) :
		shortest = [-1, sys.maxsize]
		if len(path) + 1 < len(matrix) :
			for j in range(0, len(matrix[current])) :
				if matrix[current][j] > 0 and matrix[current][j] < shortest[1] and j not in path and path + [current, j] not in failures :
					shortest = [j, matrix[current][j]]
			if (shortest[0]) >= 0 :
				path.append(current)
				current = shortest[0] # j
			else : # failure found
				failures.append(path + [current])
				if len(path) > 0 :
					current = path.pop() # reset current
				else :
					current = start
		else : # make sure that path[-1] can connect to path[0]
			if matrix[path[-1]][path[0]] > 0 : # woohoo, they connect!
				path = path + [current, path[0]]
			else : # failure
				failures.append(path + [current])
				if len(path) > 0 :
					current = path.pop() # reset current
					if len(path) > 0 :
						current = path.pop() # reset current
					else :
						current = start
				else :
					current = start
		# some debug prints, enable the sleep message otherwise it's unreadable
		#print("failures:", failures)
		#print("path:", path + [current])
		#time.sleep(0.1) 
		if path + [current] in failures or len(failures) > maxfailures :
			return [sys.maxsize, []]

	return [walk_path(path), path]

def save_matrix(filename) :
	global matrix
	with open(filename, 'w') as file :
		file.write(json.dumps(matrix))
	print("saved as", filename)

def load_matrix(filename) :
	global matrix
	with open(filename, 'r') as file :
		matrix = json.load(file)

def validate_answer(path) :
	global matrix
	if len(path) != len(matrix) + 1 or path[0] != path[-1] :
		return False
	node = 0
	while node < len(matrix) :
		if node in path :
			node = node + 1
		else :
			return False
	return True

def walk_path(path) :
	global matrix
	length = 0
	for i in range(1, len(path) - 1) :
		length = length + matrix[i-1][i]
	return length

matrix = None

size = 10
maxlen = 100
chance = 0.5
if len(sys.argv) > 1 :
	if is_int(sys.argv[1]) : size = int(sys.argv[1])
	elif os.path.isfile(sys.argv[1]) :
		load_matrix(sys.argv[1])
	if len(sys.argv) > 2 and is_int(sys.argv[2]) :
		maxlen = int(sys.argv[2])
		if len(sys.argv) > 3 and is_float(sys.argv[3]) :
			chance = float(sys.argv[3])
else :
	print("You can specify how the matrix is generated by inputting variables: python tsp.py {matrix size} {max distance} {chance of adding connection (0 to 1)} ex: python tsp.py 100 100 0.5")
	print("or simply pass the filename of a matrix in json format: python tsp.py matrix.json")

if matrix is None :
	create_matrix(size)
	randomize_matrix(maxlen, chance)

if len(matrix) <= 50 :
	print_matrix()
else :
	print("not printing matrix because it's too huge and wouldn't be helpful anyway")

print("finding smallest ", end='', flush=True)
# print dot every so many calculations
dots = len(matrix) / 100
howmanydots = 1 / dots
if howmanydots < 1 :
	howmanydots = 1
howmanydots = int(howmanydots)
printdot = 0
smallest = [sys.maxsize, []]
for i in range(len(matrix)) :
	answer = find_shortest(i)
	printdot = printdot + 1
	if printdot >= dots :
		if len(answer[1]) <= 0 :
			for j in range(howmanydots) :
				print("x", end='', flush=True)
		else :
			for j in range(howmanydots) :
				print(".", end='', flush=True)
		printdot = 0
	if smallest[0] > answer[0] :
		smallest = answer
print(" done.")
print("Is answer valid (contains every point):", validate_answer(smallest[1]))

print("distance:", smallest[0], "\npath:", smallest[1])
#print(answer[1])
#print(answer[1][:5])
filename = input("Save matrix? Enter filename to save, or leave blank to cancel. (recommended to add .json)\n>")
if len(filename) > 0 :
	save_matrix(filename)
print("done.")